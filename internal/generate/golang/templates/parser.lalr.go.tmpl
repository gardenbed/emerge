
// ActionType enumerates the possible types of actions in an LR parser.
type ActionType int

const (
	SHIFT  ActionType = 1 + iota // Advance to the next state by consuming input.
	REDUCE                       // Apply a production to reduce symbols on the stack.
	ACCEPT                       // Accept the input as successfully parsed.
	ERROR                        // Signal an error in parsing.
)

// tokenFunc is a function that is invoked each time a token
// is matched and removed from an input string during parsing.
//
// It executes the actions associated with the matched token,
// such as semantic processing, constructing abstract syntax trees (AST),
// or performing other custom logic required for the parsing process.
//
// The function may return an error, indicating an issue during token processing.
// The parser may stop immediately or continue parsing and accumulate more errors.
type tokenFunc func(*Token) error

// productionFunc is a function that is invoked each time a production rule
// is matched or applied during the parsing process of an input string.
// It passes the index of a production rule instead of the production itself.
//
// It executes the actions associated with the matched production rule,
// such as semantic processing, constructing abstract syntax trees (AST),
// or performing other custom logic required for the parsing process.
//
// The function may return an error, indicating an issue during production rule processing.
// The parser may stop immediately or continue parsing and accumulate more errors.
type productionFunc func(int) error

// EvaluateFunc is a function invoked every time a production rule
// is matched or applied during the parsing of an input string.
// It passes the index of a production rule instead of the production itself.
//
// It receives a list of values corresponding to the right-hand side of the matched production
// and expects a value to be returned representing the left-hand side of the production.
//
// The returned value will be subsequently used as an input in the evaluation of other production rules.
// Both the input and output values are of the generic type any.
//
// The caller is responsible for ensuring that each value is converted to the appropriate type based on
// the production rule and the position of the symbol corresponding to the value in the production's right-hand side.
// The input values must retain the same type they were originally evaluated as when returned.
//
// The function may return an error if there are issues with the input values,
// such as mismatched types or unexpected inputs.
type EvaluateFunc func(int, []*Value) (any, error)

// Value represents a value used during the evaluation process,
// along with its corresponding positional information in the input.
type Value struct {
	Val any
	Pos *Position
}

// String returns a string representation of a value.
func (v *Value) String() string {
	if v.Pos == nil || v.Pos.IsZero() {
		return fmt.Sprintf("%v", v.Val)
	}

	return fmt.Sprintf("%v <%s>", v.Val, v.Pos)
}

// ParseError represents an error encountered when parsing an input string.
type ParseError struct {
	Description string
	Cause       error
	Pos         Position
}

// Error implements the error interface.
// It returns a formatted string describing the error in detail.
func (e *ParseError) Error() string {
	var b bytes.Buffer

	if !e.Pos.IsZero() {
		fmt.Fprintf(&b, "%s", e.Pos)
	}

	if len(e.Description) != 0 {
		if b.Len() > 0 {
			fmt.Fprint(&b, ": ")
		}
		fmt.Fprintf(&b, "%s", e.Description)
	}

	if e.Cause != nil {
		if b.Len() > 0 {
			fmt.Fprint(&b, ": ")
		}
		fmt.Fprintf(&b, "%s", e.Cause)
	}

	return b.String()
}

// Unwrap implements the unwrap interface.
func (e *ParseError) Unwrap() error {
	return e.Cause
}

/* ------------------------------------------------------------------------------------------------------------------------ */

// Parser is the parser, a.k.a. syntax analyzer.
type Parser struct {
	L *Lexer
}

// NewParser creates a new parser, a.k.a. syntax analyzer.
func NewParser(filename string, src io.Reader) (*Parser, error) {
	L, err := NewLexer(filename, src)
	if err != nil {
		return nil, err
	}

	return &Parser{
		L: L,
	}, nil
}

// nextToken wraps the Lexer.NextToken method and ensures an endmarker token is returned when the end of input is reached.
func (p *Parser) nextToken() (Token, error) {
	token, err := p.L.NextToken()
	if err != nil && errors.Is(err, io.EOF) {
		token.Terminal, token.Lexeme = endmarker, ""
		return token, nil
	}

	return token, err
}

// parse implements the LR parsing algorithm.
// It analyzes a sequence of input tokens (terminal symbols) provided by the lexical analyzer.
// It attempts to parse the input according to the production rules of the grammar.
//
// The parse method invokes the provided functions each time a token or a production rule is matched.
// This allows the caller to process or react to each step of the parsing process.
//
// An error is returned if the input fails to conform to the grammar rules, indicating a syntax issue,
// or if any of the provided functions return an error, indicating a semantic issue.
func (p *Parser) parse(tokenF tokenFunc, prodF productionFunc) error {
	stack := newStack[int](1024)
	stack.Push(0)

	// Read the first input token.
	token, err := p.nextToken()
	if err != nil {
		return &ParseError{Cause: err}
	}

	for {
		s, _ := stack.Peek()
		a := token.Terminal

		action, param, err := ACTION(s, a)
		if err != nil {
			return &ParseError{
				Description: fmt.Sprintf("unexpected string %q", token.Lexeme),
				Cause:       err,
				Pos:         token.Pos,
			}
		}

		switch action {
		case SHIFT:
			stack.Push(param)

			// Yield the token.
			if tokenF != nil {
				if err := tokenF(&token); err != nil {
					return &ParseError{
						Cause: err,
						Pos:   token.Pos,
					}
				}
			}

			// Read the next input token.
			token, err = p.nextToken()
			if err != nil {
				return &ParseError{Cause: err}
			}

		case REDUCE:
			A, β := Grammar.Productions[param].Head, Grammar.Productions[param].Body

			for range len(β) {
				stack.Pop()
			}

			// An LR parser detects an error when it consults the ACTION table.
			// Errors are never identified by consulting the GOTO table.
			// If ACTION(s, a) is not an error entry, GOTO(t, A) will also not be an error entry.

			t, _ := stack.Peek()
			next := GOTO(t, A)
			stack.Push(next)

			// Yield the production.
			if prodF != nil {
				if err := prodF(param); err != nil {
					return &ParseError{Cause: err}
				}
			}

		case ACCEPT:
			// Accept the input string.
			return nil

		case ERROR:
			// This is unreachable currently, since ACTION handles the error.
		}
	}
}

// ParseAndBuildAST implements the LR parsing algorithm.
// It analyzes a sequence of input tokens (terminal symbols) provided by the lexical analyzer.
// It attempts to parse the input according to the production rules of the grammar.
//
// If the input string is valid, the root node of the BNF AST is returned,
// representing the syntactic structure of the input string.
//
// An error is returned if the input fails to conform to the grammar rules, indicating a syntax issue.
func (p *Parser) ParseAndBuildAST() (Node, error) {
	// Stack for constructing the abstract syntax tree.
	nodes := newStack[Node](1024)

	err := p.parse(
		func(token *Token) error {
			nodes.Push(&LeafNode{
				Terminal: token.Terminal,
				Lexeme:   token.Lexeme,
				Position: token.Pos,
			})

			return nil
		},
		func(i int) error {
			prod := Grammar.Productions[i]

			in := &InternalNode{
				NonTerminal: prod.Head,
				Production:  prod,
			}

			for range len(prod.Body) {
				child, _ := nodes.Pop()
				in.Children = append([]Node{child}, in.Children...) // Maintain correct production body order
			}

			nodes.Push(in)

			return nil
		},
	)

	if err != nil {
		return nil, err
	}

	// The nodes stack only contains the root of AST at this point.
	root, _ := nodes.Pop()

	return root, nil
}

// ParseAndEvaluate implements the LR parsing algorithm.
// It analyzes a sequence of input tokens (terminal symbols) provided by the lexical analyzer.
// It attempts to parse the input according to the production rules of the grammar.
//
// During the parsing process, the provided EvaluateFunc is invoked each time a production rule is matched.
// The function is called with values corresponding to the symbols in the body of the production,
// enabling the caller to process and evaluate the input incrementally.
//
// An error is returned if the input fails to conform to the grammar rules, indicating a syntax issue,
// or if the evaluation function returns an error, indicating a semantic issue.
func (p *Parser) ParseAndEvaluate(eval EvaluateFunc) (*Value, error) {
	// Stack for constructing the evaluation hierarchy.
	values := newStack[*Value](1024)

	err := p.parse(
		func(token *Token) error {
			copy := token.Pos
			values.Push(&Value{
				Val: token.Lexeme,
				Pos: &copy,
			})

			return nil
		},
		func(i int) error {
			l := len(Grammar.Productions[i].Body)
			rhs := make([]*Value, l)

			// Maintain correct production body order
			for i := l - 1; i >= 0; i-- {
				v, _ := values.Pop()
				rhs[i] = v
			}

			lhs, err := eval(i, rhs)
			if err != nil {
				return err
			}

			v := &Value{Val: lhs}
			if l > 0 {
				v.Pos = rhs[0].Pos
			}

			values.Push(v)

			return nil
		},
	)

	if err != nil {
		return nil, err
	}

	// The values stack only contains the root of AST at this point.
	root, _ := values.Pop()

	return root, nil
}

/* ------------------------------------------------------------------------------------------------------------------------ */

// ACTION looks up and returns the action for state s and terminal a.
func ACTION(s int, a Terminal) (ActionType, int, error) {
	switch s {
{{- range $s := .ParsingTable.States }}{{ if hasAnyACTION $.ParsingTable $s (appendEndmarker $.Terminals) }}
	case {{ $s }}:
		switch a {
		{{- range $a := (appendEndmarker $.Terminals) }}
		{{- if $action := lookupACTION $.ParsingTable $s $a }}
		{{- if equalEndmarker $a }}{{/* grammar.Endmarker */}}
		case endmarker:
		{{- else }}
		case {{ printf "%s" $a }}:
		{{- end }}
		{{- if eq $action.Type 1 }}{{/* SHIFT */}}
			return SHIFT, {{ printf "%d" $action.State }}, nil // {{ printf "%s" $action }}
		{{- else if eq $action.Type 2 }}{{/* REDUCE */}}
			{{- $i := findProductionIndex $.Productions $action.Production }}
			{{- if ne $i -1 }}
			return REDUCE, {{ printf "%d" $i }}, nil // {{ printf "%s" $action }}
			{{- end }}
		{{- else if eq $action.Type 3 }}{{/* ACCEPT */}}
			return ACCEPT, 0, nil // ACCEPT
		{{- end }}
		{{- end }}
		{{- end }}
		}
{{ end }}{{ end }}
	}

	return ERROR, -1, fmt.Errorf("no action exists in the parsing table for ACTION[%d, %s]", s, a)
}

// GOTO looks up and returns the next state for state s and non-terminal A.
func GOTO(s int, A NonTerminal) int {
	switch s {
{{- range $s := .ParsingTable.States }}{{ if hasAnyGOTO $.ParsingTable $s $.NonTerminals }}
	case {{ $s }}:
		switch A {
		{{- range $A := $.NonTerminals }}
		{{- if $next := lookupGOTO $.ParsingTable $s $A }}
		case {{ printf "%q" $A }}:
			return {{ $next }}
		{{- end }}
		{{- end }}
		}
{{ end }}{{ end }}
	}

	return -1
}

/* ------------------------------------------------------------------------------------------------------------------------ */

var Grammar = struct {
	Terminals    []Terminal
	NonTerminals []NonTerminal
	Productions  []*Production
}{
	// Terminals is an ordered list of terminal symbols for the grammar.
	Terminals: []Terminal{
{{- range .Terminals }}
		{{ . }},
{{- end }}
	},

	// NonTerminals is an ordered list of non-terminal symbols for the grammar.
	NonTerminals: []NonTerminal{
{{- range .NonTerminals }}
		{{ printf "%q" . }},
{{- end }}
	},

	// Productions is an ordered list of productions rules for the grammar.
	Productions: []*Production{
{{- range $i, $prod := .Productions }}
		/* {{ printf "%3d" $i}}: {{ printf "%s" $prod }} */ {Head: {{ printf "%q" $prod.Head }}, Body: String[Symbol]{ {{- formatSymbolString $prod.Body -}} }},
{{- end }}
	},
}

/* ------------------------------------------------------------------------------------------------------------------------ */
