
// ActionType enumerates the possible types of actions in an LR parser.
type ActionType int

const (
	SHIFT  ActionType = 1 + iota // Advance to the next state by consuming input.
	REDUCE                       // Apply a production to reduce symbols on the stack.
	ACCEPT                       // Accept the input as successfully parsed.
	ERROR                        // Signal an error in parsing.
)

// TokenFunc is a function that is invoked each time a token
// is matched and removed from an input string during parsing.
//
// It executes the actions associated with the matched token,
// such as semantic processing, constructing abstract syntax trees (AST),
// or performing other custom logic required for the parsing process.
//
// The function may return an error, indicating an issue during token processing.
// The parser may stop immediately or continue parsing and accumulate more errors.
type TokenFunc func(*Token) error

// ProductionFunc is a function that is invoked each time a production rule
// is matched or applied during the parsing process of an input string.
// It passes the index of a production rule instead of the production itself.
//
// It executes the actions associated with the matched production rule,
// such as semantic processing, constructing abstract syntax trees (AST),
// or performing other custom logic required for the parsing process.
//
// The function may return an error, indicating an issue during production rule processing.
// The parser may stop immediately or continue parsing and accumulate more errors.
type ProductionFunc func(int) error

// EvaluateFunc is a function invoked every time a production rule
// is matched or applied during the parsing of an input string.
// It passes the index of a production rule instead of the production itself.
//
// It receives a list of values corresponding to the right-hand side of the matched production
// and expects a value to be returned representing the left-hand side of the production.
//
// The returned value will be subsequently used as an input in the evaluation of other production rules.
// Both the input and output values are of the generic type any.
//
// The caller is responsible for ensuring that each value is converted to the appropriate type based on
// the production rule and the position of the symbol corresponding to the value in the production's right-hand side.
// The input values must retain the same type they were originally evaluated as when returned.
//
// The function may return an error if there are issues with the input values,
// such as mismatched types or unexpected inputs.
type EvaluateFunc func(int, []*Value) (any, error)

// Value represents a value used during the evaluation process,
// along with its corresponding positional information in the input.
type Value struct {
	Val any
	Pos *Position
}

// String returns a string representation of a value.
func (v *Value) String() string {
	if v.Pos == nil || v.Pos.IsZero() {
		return fmt.Sprintf("%v", v.Val)
	}

	return fmt.Sprintf("%v <%s>", v.Val, v.Pos)
}

// ParseError represents an error encountered when parsing an input string.
type ParseError struct {
	Description string
	Cause       error
	Pos         Position
}

// Error implements the error interface.
// It returns a formatted string describing the error in detail.
func (e *ParseError) Error() string {
	var b bytes.Buffer

	if !e.Pos.IsZero() {
		fmt.Fprintf(&b, "%s", e.Pos)
	}

	if len(e.Description) != 0 {
		if b.Len() > 0 {
			fmt.Fprint(&b, ": ")
		}
		fmt.Fprintf(&b, "%s", e.Description)
	}

	if e.Cause != nil {
		if b.Len() > 0 {
			fmt.Fprint(&b, ": ")
		}
		fmt.Fprintf(&b, "%s", e.Cause)
	}

	return b.String()
}

// Unwrap implements the unwrap interface.
func (e *ParseError) Unwrap() error {
	return e.Cause
}

/* ------------------------------------------------------------------------------------------------------------------------ */

// Parser is the parser, a.k.a. syntax analyzer.
type Parser struct {
	L *Lexer
}

// NewParser creates a new parser, a.k.a. syntax analyzer.
func NewParser(filename string, src io.Reader) (*Parser, error) {
	L, err := NewLexer(filename, src)
	if err != nil {
		return nil, err
	}

	return &Parser{
		L: L,
	}, nil
}

// nextToken wraps the Lexer.NextToken method and ensures an endmarker token is returned when the end of input is reached.
func (p *Parser) nextToken() (Token, error) {
	token, err := p.L.NextToken()
	if err != nil && errors.Is(err, io.EOF) {
		token.Terminal, token.Lexeme = endmarker, ""
		return token, nil
	}

	return token, err
}

// parse implements the LR parsing algorithm.
// It analyzes a sequence of input tokens (terminal symbols) provided by the lexical analyzer.
// It attempts to parse the input according to the production rules of the grammar.
//
// The parse method invokes the provided functions each time a token or a production rule is matched.
// This allows the caller to process or react to each step of the parsing process.
//
// An error is returned if the input fails to conform to the grammar rules, indicating a syntax issue,
// or if any of the provided functions return an error, indicating a semantic issue.
func (p *Parser) parse(tokenF TokenFunc, prodF ProductionFunc) error {
	stack := newStack[int](1024)
	stack.Push(0)

	// Read the first input token.
	token, err := p.nextToken()
	if err != nil {
		return &ParseError{Cause: err}
	}

	for {
		s, _ := stack.Peek()
		a := token.Terminal

		action, param, err := ACTION(s, a)
		if err != nil {
			return &ParseError{
				Description: fmt.Sprintf("unexpected string %q", token.Lexeme),
				Cause:       err,
				Pos:         token.Pos,
			}
		}

		switch action {
		case SHIFT:
			stack.Push(param)

			// Yield the token.
			if tokenF != nil {
				if err := tokenF(&token); err != nil {
					return &ParseError{
						Cause: err,
						Pos:   token.Pos,
					}
				}
			}

			// Read the next input token.
			token, err = p.nextToken()
			if err != nil {
				return &ParseError{Cause: err}
			}

		case REDUCE:
			A, β := Grammar.Productions[param].Head, Grammar.Productions[param].Body

			for range len(β) {
				stack.Pop()
			}

			// An LR parser detects an error when it consults the ACTION table.
			// Errors are never identified by consulting the GOTO table.
			// If ACTION(s, a) is not an error entry, GOTO(t, A) will also not be an error entry.

			t, _ := stack.Peek()
			next := GOTO(t, A)
			stack.Push(next)

			// Yield the production.
			if prodF != nil {
				if err := prodF(param); err != nil {
					return &ParseError{Cause: err}
				}
			}

		case ACCEPT:
			// Accept the input string.
			return nil

		case ERROR:
			// This is unreachable currently, since ACTION handles the error.
		}
	}
}

/* ------------------------------------------------------------------------------------------------------------------------ */

// ACTION looks up and returns the action for state s and terminal a.
func ACTION(s int, a Terminal) (ActionType, int, error) {
	switch s {

	}

	return ERROR, -1, fmt.Errorf("no action exists in the parsing table for ACTION[%d, %s]", s, a)
}

// GOTO looks up and returns the next state for state s and non-terminal A.
func GOTO(s int, A NonTerminal) int {
	switch s {

	}

	return -1
}

/* ------------------------------------------------------------------------------------------------------------------------ */

var Grammar = struct {
  Terminals    []Terminal
  NonTerminals []NonTerminal
  Productions  []*Production
}{
	// terminals is an ordered list of terminal symbols for the grammar.
	Terminals: []Terminal{
{{- range .Terminals }}
		{{ . }},
{{- end }}
	},

	// nonTerminals is an ordered list of non-terminal symbols for the grammar.
	NonTerminals: []NonTerminal{
{{- range .NonTerminals }}
		{{ printf "%q" . }},
{{- end }}
	},

	// productions is an ordered list of productions rules for the grammar.
	Productions: []*Production{
{{- range $i, $prod := .Productions }}
    /* {{ printf "%3d" $i}}: {{ printf "%s" $prod }} */ {Head: {{ printf "%q" $prod.Head }}, Body: String[Symbol]{ {{- formatSymbolString $prod.Body -}} }},
{{- end }}
	},
}

/* ------------------------------------------------------------------------------------------------------------------------ */
