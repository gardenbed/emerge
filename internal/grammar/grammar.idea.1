

// EliminateCycle receives a context-free grammar and returns an equivalent grammar that has no cycle.
//
// A grammar is cyclic if it has derivations of one or more steps in which A ⇒* A for some non-terminal A.
func (g *CFG) EliminateCycle() *CFG {
	return nil
}


// EliminateLeftRecursion receives a context-free grammar and returns an equivalent grammar with no left recursion.
//
// A grammar is left-recursive if it has a non-terminal A such that there is a derivation A +⇒ Aα for some string.
// For top-down parsers, left recursion causes the parser to loop forever.
// Many bottom-up parsers also will not accept left-recursive grammars.
func (g *CFG) EliminateLeftRecursion() *CFG {
	h := &CFG{}

	// TODO:
	/* for i := range g.NonTerminals {
		Ai := g.NonTerminals[i]

		for j := 0; j < i; j++ {
			Aj := g.NonTerminals[i]

			for _, p := range g.Productions {
				if p.Head == Ai {
					if s, ok := p.Body[0].(NonTerminal); ok && s == Aj {

					} else {

					}
				}
			}
		}
	} */

	return h
}


// LeftFactor receives a context-free grammar and returns an equivalent left-factored grammar.
//
// Left factoring is a grammar transformation for producing a grammar suitable for top-down parsing.
// When the choice between two alternative A-productions is not clear, we may be able to rewrite the productions
// to defer the decision until enough of the input has been seen that we can make the right choice.
func (g *CFG) LeftFactor() *CFG {
	h := &CFG{}

	// TODO:

	return h
}

